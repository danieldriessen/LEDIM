"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Font: () => Font,
  GpioMapping: () => GpioMapping,
  HorizontalAlignment: () => HorizontalAlignment,
  LayoutUtils: () => LayoutUtils,
  LedMatrix: () => LedMatrix,
  LedMatrixUtils: () => LedMatrixUtils,
  MuxType: () => MuxType,
  PixelMapperType: () => PixelMapperType,
  RowAddressType: () => RowAddressType,
  RuntimeFlag: () => RuntimeFlag,
  ScanMode: () => ScanMode,
  VerticalAlignment: () => VerticalAlignment,
  isSupported: () => isSupported
});
module.exports = __toCommonJS(index_exports);
var import_node_module = require("module");

// src/layout-utils.ts
var isSeparator = ({ char }) => char === " ";
var glphysToWords = (glphys) => {
  const index = glphys.map((g, i) => i === 0 && isSeparator(g) ? null : g.char).indexOf(" ");
  return index > 0 ? [glphys.slice(0, index), ...glphysToWords(glphys.slice(index))] : [glphys];
};
var calcWordWidth = (gs) => gs.reduce((sum, { w }) => sum + w, 0);
var wordsToLines = (maxWidth, words) => {
  const lines = [];
  let tmpLine = [];
  let tmpLineWidth = 0;
  words.filter(({ length }) => length > 0).forEach((word) => {
    const wordWidth = calcWordWidth(word);
    if (tmpLineWidth + wordWidth > maxWidth) {
      lines.push(tmpLine);
      const firstWord = word.filter((g) => !isSeparator(g));
      tmpLine = [firstWord];
      tmpLineWidth = calcWordWidth(firstWord);
    } else {
      tmpLine.push(word);
      tmpLineWidth += wordWidth;
    }
  });
  if (tmpLine.length > 0) lines.push(tmpLine);
  return lines;
};
var HorizontalAlignment = /* @__PURE__ */ ((HorizontalAlignment2) => {
  HorizontalAlignment2["Left"] = "left";
  HorizontalAlignment2["Center"] = "center";
  HorizontalAlignment2["Right"] = "right";
  return HorizontalAlignment2;
})(HorizontalAlignment || {});
var VerticalAlignment = /* @__PURE__ */ ((VerticalAlignment2) => {
  VerticalAlignment2["Bottom"] = "bottom";
  VerticalAlignment2["Middle"] = "middle";
  VerticalAlignment2["Top"] = "top";
  return VerticalAlignment2;
})(VerticalAlignment || {});
var LayoutUtils = class {
  static textToLines(font, maxW, text) {
    const fontHeight = font.height();
    const glphys = text.split("").map((char) => ({
      char,
      h: fontHeight,
      w: font.stringWidth(char)
    }));
    return wordsToLines(maxW, glphysToWords(glphys));
  }
  static linesToMappedGlyphs(lines, lineH, containerW, containerH, alignH = "center" /* Center */, alignV = "middle" /* Middle */) {
    const blockH = lineH * lines.length;
    const offsetY = (() => {
      switch (alignV) {
        case "top" /* Top */:
          return 0;
        case "middle" /* Middle */:
          return Math.floor((containerH - blockH) / 2);
        case "bottom" /* Bottom */:
          return containerH - blockH;
      }
    })();
    return lines.map((words, i) => {
      const lineGlyphs = words.reduce(
        (glyphs, word) => [...glyphs, ...word],
        []
      );
      const lineW = calcWordWidth(lineGlyphs);
      let offsetX = (() => {
        switch (alignH) {
          case "left" /* Left */:
            return 0;
          case "center" /* Center */:
            return Math.floor((containerW - lineW) / 2);
          case "right" /* Right */:
            return containerW - lineW;
        }
      })();
      return lineGlyphs.map((glyph) => {
        const mapped = {
          ...glyph,
          x: offsetX,
          y: offsetY + i * lineH
        };
        offsetX += glyph.w;
        return mapped;
      });
    }).reduce((glyphs, words) => [...glyphs, ...words], []);
  }
};

// src/types.ts
var ScanMode = /* @__PURE__ */ ((ScanMode2) => {
  ScanMode2[ScanMode2["Progressive"] = 0] = "Progressive";
  ScanMode2[ScanMode2["Interlaced"] = 1] = "Interlaced";
  return ScanMode2;
})(ScanMode || {});
var MuxType = /* @__PURE__ */ ((MuxType2) => {
  MuxType2[MuxType2["Direct"] = 0] = "Direct";
  MuxType2[MuxType2["Stripe"] = 1] = "Stripe";
  MuxType2[MuxType2["Checker"] = 2] = "Checker";
  MuxType2[MuxType2["Spiral"] = 3] = "Spiral";
  MuxType2[MuxType2["ZStripe"] = 4] = "ZStripe";
  MuxType2[MuxType2["ZnMirrorZStripe"] = 5] = "ZnMirrorZStripe";
  MuxType2[MuxType2["Coreman"] = 6] = "Coreman";
  MuxType2[MuxType2["Kaler2Scan"] = 7] = "Kaler2Scan";
  MuxType2[MuxType2["ZStripeUneven"] = 8] = "ZStripeUneven";
  MuxType2[MuxType2["P10128x4Z"] = 9] = "P10128x4Z";
  MuxType2[MuxType2["QiangLiQ8"] = 10] = "QiangLiQ8";
  MuxType2[MuxType2["InversedZStripe"] = 11] = "InversedZStripe";
  MuxType2[MuxType2["P10Outdoor1R1G1BMultiplexMapper1"] = 12] = "P10Outdoor1R1G1BMultiplexMapper1";
  MuxType2[MuxType2["P10Outdoor1R1G1BMultiplexMapper2"] = 13] = "P10Outdoor1R1G1BMultiplexMapper2";
  MuxType2[MuxType2["P10Outdoor1R1G1BMultiplexMapper3"] = 14] = "P10Outdoor1R1G1BMultiplexMapper3";
  MuxType2[MuxType2["P10CoremanMapper"] = 15] = "P10CoremanMapper";
  MuxType2[MuxType2["P8Outdoor1R1G1BMultiplexMapper"] = 16] = "P8Outdoor1R1G1BMultiplexMapper";
  MuxType2[MuxType2["FlippedStripeMultiplexMapper"] = 17] = "FlippedStripeMultiplexMapper";
  MuxType2[MuxType2["P10Outdoor32x16HalfScanMapper"] = 18] = "P10Outdoor32x16HalfScanMapper";
  return MuxType2;
})(MuxType || {});
var PixelMapperType = /* @__PURE__ */ ((PixelMapperType2) => {
  PixelMapperType2["Chainlink"] = "Chainlink";
  PixelMapperType2["U"] = "U-mapper";
  PixelMapperType2["Rotate"] = "Rotate";
  PixelMapperType2["V"] = "V-mapper";
  PixelMapperType2["VZ"] = "V-mapper:Z";
  return PixelMapperType2;
})(PixelMapperType || {});
var RuntimeFlag = /* @__PURE__ */ ((RuntimeFlag2) => {
  RuntimeFlag2[RuntimeFlag2["Disabled"] = -1] = "Disabled";
  RuntimeFlag2[RuntimeFlag2["Off"] = 0] = "Off";
  RuntimeFlag2[RuntimeFlag2["On"] = 1] = "On";
  return RuntimeFlag2;
})(RuntimeFlag || {});
var RowAddressType = /* @__PURE__ */ ((RowAddressType2) => {
  RowAddressType2[RowAddressType2["Direct"] = 0] = "Direct";
  RowAddressType2[RowAddressType2["AB"] = 1] = "AB";
  RowAddressType2[RowAddressType2["DirectRow"] = 2] = "DirectRow";
  RowAddressType2[RowAddressType2["ABC"] = 3] = "ABC";
  RowAddressType2[RowAddressType2["ABCShift"] = 4] = "ABCShift";
  return RowAddressType2;
})(RowAddressType || {});
var GpioMapping = /* @__PURE__ */ ((GpioMapping2) => {
  GpioMapping2["Regular"] = "regular";
  GpioMapping2["AdafruitHat"] = "adafruit-hat";
  GpioMapping2["AdafruitHatPwm"] = "adafruit-hat-pwm";
  GpioMapping2["RegularPi1"] = "regular-pi1";
  GpioMapping2["Classic"] = "classic";
  GpioMapping2["ClassicPi1"] = "classic-pi1";
  return GpioMapping2;
})(GpioMapping || {});

// src/utils.ts
var LedMatrixUtils = class {
  static encodeMappers(...mappers) {
    return mappers.map((mapper) => {
      switch (mapper.type) {
        case "Chainlink" /* Chainlink */:
          return "Chainlink" /* Chainlink */;
        case "Rotate" /* Rotate */:
          return ["Rotate" /* Rotate */, mapper.angle].join(":");
        case "U-mapper" /* U */:
          return "U-mapper" /* U */;
        case "V-mapper" /* V */:
          return "V-mapper" /* V */;
        case "V-mapper:Z" /* VZ */:
          return "V-mapper:Z" /* VZ */;
      }
    }).join(";");
  }
};

// src/index.ts
var import_meta = {};
var { Font, isSupported, LedMatrix } = (() => {
  try {
    return (0, import_node_module.createRequire)(import_meta.url)(
      "../build/Release/rpi-led-matrix.node"
    );
  } catch {
    return require("../build/Release/rpi-led-matrix.node");
  }
})();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Font,
  GpioMapping,
  HorizontalAlignment,
  LayoutUtils,
  LedMatrix,
  LedMatrixUtils,
  MuxType,
  PixelMapperType,
  RowAddressType,
  RuntimeFlag,
  ScanMode,
  VerticalAlignment,
  isSupported
});
